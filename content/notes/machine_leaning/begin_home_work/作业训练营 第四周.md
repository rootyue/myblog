---
title: "机器学习基础作业班 第四周"
tags:
- 机器学习
---

如果在上次的作业中, 你使用PyTorch实现了LeNet网络的定义的话, 你应当已经知道一个网络的定义过程了。把 对应的功能封装成函数后根据你对网络的设计将这些零件拼装在一起, 现在我们会用到全连接层、卷积层、池化 层和激活函数, 之后随着网络设计的复杂, 你会见到更多的零件, 比如dropout、Batch normalization等等。所以 先学理论, 搞清楚这些零件的作用, 以及网络的结构, 用代码实现只是分分钟的事儿。

以下是一个可以用来实现LeNet网络的class, 目的是之后实例出这个网络去跑MNIST数据集。上次有同学说定义 网络不可思议, 你看看是不是我说的零件拼装, 搞定这个以后理论上你可以尝试自己去构建你的网络了。
```python
import torch
import torch.nn as nn 
class LeNet(nn.Module):
    def __init__(self):
        super(LeNet, self).__init__()
        self.conv1 = nn.Conv2d(1, 6, 5)
        self.pool1 = nn.MaxPool2d(2, 2)
        self.conv2 = nn.Conv2d(6, 16, 5)
        self.pool2 = nn.MaxPool2d(2, 2)
        self.fc1 = nn.Linear(16 * 4 * 4, 120)
        self.fc2 = nn.Linear(120, 84)
        self.fc3 = nn.Linear(84, 10)
    def forward(self, x):
        x = self.pool1(torch.sigmoid(self.conv1(x)))
        x = self.pool2(torch.sigmoid(self.conv2(x)))
        x = x.view(-1, 16 * 4 * 4)
        x = torch.sigmoid(self.fc1(x))
        x = torch.sigmoid(self.fc2(x))
        x = self.fc3(x)
    return x
```

参考上例回答


### (1) init (self) 部分定义了什么?
定义了一些网络层，其中有卷积层，最大池化层和全连接层

conv1为 输入通道数1，输出通道数6，卷积核大小为5x5的卷积层，

pool1为 卷积核大小为2x2 步长为2 的最大池化层，

conv2为 输入通道数6，输出通道数16，卷积核大小为5x5的卷积层，

pool2为 卷积核大小为2x2 步长为2 的最大池化层，

fc1为 输入张量特征数为16x4x4=256，输出特征数为120 的全连接层

fc2为 输入张量特征数为120，输出特征数为84 的全连接层

fc3为 输入张量特征数为84，输出特征数为10 的全连接层


### (2) forward (self, x ) 部分定义了什么?
将__init__(self)初始化过程中创建的网络层进行连接，其中还添加了sigmoid激活函数，流程大致为：

输入 → conv1 卷积层 → sigmoid激活函数 → pool1最大池化 → conv2卷积层 →

sigmoid激活函数 → pool2最大池化 → view卷积层摊平操作，用于拼接后续的全连接层 →

fc1全连接层 → fc2全连接层 → fc3全连接层 →输出


### (3) nn. Linear 的作用是什么?
可以创建一个全连接层，创建时可以定义输入特征数和输出的特征数
  

### (4) x.view \((-1,16 * 4 * 4)\) 的作用是什么? 为什么需要这么做?
> x.view(-1, 16 * 4 * 4) 表示将x张量重塑为一个形状为[-1, 16 * 4 * 4]的新张量。其中，-1表示该维度将由计算机自动确定，以确保张量大小保持不变。在这里，它将被设置为batch size，也就是输入张量的第一维度的大小。16 * 4 * 4表示16个特征图，每个特征图的大小为4x4。在LeNet网络中的结构中，可以发现在第二个池化层后，输出张量的大小为[batch_size, 16, 4, 4]。因此，执行 x.view(-1, 16 * 4 * 4) 操作后，输出张量的大小为[batch_size, 16 * 4 * 4]，将被用于全连接层的输入。这个过程可以理解为将特征图展平成一维向量，便于全连接层进行线性变换操作。在卷积神经网络中，这种展平的操作是一个很常见的操作。
  

### (5)怎么是" 16 x 4 x4"?论文的结构图中不是" 16 x 5 x5"? 为什么会换?
> 因为原论文的数据集输入的图片大小为32x32，而我们这里的代码使用到的数据集图片输入维度为28x28，所以想要去适配新的数据集输入维度（因为网络结构后面存在全连接层，到全连接层输入的时候维度是固定的），就需要去进行相应的修改
  

这段代码里面涉及到了Python类的定义和初始化方法等基础知识, 不了解的话去看Python的函数

这段代码⾥⾯涉及到了Python类的定义和初始化⽅法等基础知识，不了解的话去看Python的函数 https://docs.python.org/zh-cn/3/tutorial/controlﬂow.html#deﬁning-functions 与类 https://docs.python.org/zh-cn/3/tutorial/classes.html 这⼀部分。  模型被定义好后，使⽤之前需要先实例出来，⽐如


```python
net = LeNet()
```


下面来看看一个网络的训练是怎么进行的。
  

先来准备好数据, 现在以MNIST数据集为例。


```python
import numpy as np
train_X, test_X, train_y, test_y = np.load( './mnist.npy', allow_pickle=True)
x_train = train_X.reshape(60000, 28*28).astype(np.float32) 
x_test = test_X.reshape(10000, 28*28).astype(np.float32)
```  

现在我们要把数据集处理一下再用作训练, 对于当前数据集, 需要有以下几步：
  
1. 转换成 tensor 类型
2. 再转换成 Dataset 类型
3. 再生成 DataLoader

这几步是先后依赖的。我们想用小批量随机下降的方法来进行模型的训练, 所以需要借助 DataLoader 来进行 数据的批量加载-> DataLoader 在创建的时候需要数据是 Dataset 类型-> Dataset 类型的创建需要数据是 tensor 类型。


下面具体来说, 首先将 NumPy 加载进来的数据类型 ndarray 转换成 tensor 类型:

```python
x_train, y_train, x_test, y_test = map(torch.tensor, (x_train, train_y, x_test, test_y))
```
  
### (6) map 函数Python中很常使用到，在这里的作用是什么?
> map(function, iterable, ...) 
> map函数可以使用第一个给定的函数将后面给定的可迭代对象中的元素进行相同的处理（使用给定的函数进行处理），最后将处理之后的可迭代对象进行返回。这里的作用就是将给定的训练集和测试集数据从numpy的ndarray转换为pytorch中的张量（tensor）进行返回。

下面是生成 Dataset 类。

```python
from torch.utils.data import TensorDataset
```
  
x_train 和  y_train 都可以合并为⼀个  TensorDataset ，这将更易于迭代和切⽚。

```python
train_ds = TensorDataset(x_train, y_train)
```
  

在我们自己定义数据集的时候, 可以使用 PyTorch 的 TensorDataset 来实现这一步, 可是(7)我们为什么需 要这么做?
>在深度学习的模型训练中，通常需要同时处理大量的数据，而这些数据通常存储在数组、数组列表、字典等形式的数据结构中。每次从中分批次读取一部分数据，然后对其进行计算。但如果我们每次都直接从存储数据的数据结构中读取数据，会导致每次读取数据的时间都要花费一定的时间，并降低训练的效率。因此，在实际的开发中，通常需要将数据集封装为一个可迭代的数据流，以便于高效地读取数据。

> 在PyTorch中，我们通常使用`DataLoader`对象来定义一个可迭代的数据集。`DataLoader`对象可以设置批量大小，并自动从数据集中读取批量大小的数据并返回。此外，它还可以随机打乱数据集，使得模型能够更好地学习数据集中的规律。

> 而`TensorDataset`是 PyTorch 提供的一种数据集对象，可以方便地将数据集中的数据与标签封装成一个整体，方便将数据集作为一个整体传递给`DataLoader`，以供模型读取和训练。`TensorDataset`的主要作用是将多个Tensor数组打包起来，成为一个元素的形式，并提供一个默认的索引方法，方便管理和使用数据。将训练和验证数据转化为`TensorDataset`对象后，可以将对象传给`DataLoader`对象，并设置批量大小和其他参数，以便高效地读取和使用训练和验证数据。

> 因此，数据集的封装可以提高模型的训练效率和程序的可读性。而`TensorDataset`和`DataLoader`这两种类的结合使用，可以使程序更加清晰简洁，且具有更好的数据索引和读取方式，从而加快深度学习模型的训练效率。

> 除此之外, Pytorch 的 DataLoader 负责批次管理。需要从 Dataset 创建一个 DataLoader。 DataLoader 使迭代变得更加容易, 可以自动为我们提供随机打乱的每个小批量。

```python
from torch.utils.data import DataLoader 
bs = 64
train_ds = TensorDataset(x_train, y_train)
train_dl = DataLoader(train_ds, batch_size=bs, shuffle=True)
```
  

现在, 训练时使用的数据加载器已经处理好了, 来写一个训练过程。


补充:

  

1. 通常管所有数据扫完一遍叫做一个epoch。

```python
epochs = 32
```

2. Pytorch 还提供了一个包含各种优化算法的软件包 torch.optim。我们可以使用优化器中的step方法来进 行参数的更新 (注意：loss.backward() 只是求得了每一个参数的梯度并且记录在参数对应的节点上, 但 是参数并不更新)。

```python
from torch import optim
opt = optim.SGD(net.parameters(), lr=0.01) # 定义⼀个优化器
```


3. 学习率记作 Ir

  
```python
lr = 0.01
```
  

4. 损失函数也提前准备好

```python
import torch.nn.functional as F loss_func = F.cross_entropy
```
  

现在开始训练吧。

  
```python
for epoch in range(epochs):
    for xb, yb in train_dl:
        xb = torch.reshape(xb, [-1, 1, 28, 28])
        pred = net(xb)
        loss = loss_func(pred, yb)
        loss.backward()
        opt.step()
        opt.zero_grad()
        print(epoch, loss)
```
  

### 上例中, (8) torch.reshape (xb，\[-1，1，28，28\]). 的作用是什么?

在代码中，`torch.reshape(xb, [-1, 1, 28, 28])`的作用是将形状为 `(batch_size, n_inputs)` 的二维张量 `xb` 重塑为一个四维张量，其形状为 `(batch_size, 1, 28, 28)`，以便于在`LeNet`模型中使用。这相当于把一批 `batch_size` 个平面图像数据堆叠成一个 4 维的张量。其中，第一个维度表示批次大小(batch_size)，第二个维度表示通道数(channel), 1 表示灰度图像，第三个和第四个维度分别表示图像的高和宽。

PyTorch中神经网络的输入通常是一个4维张量，包括 batch_size，channel，height，width 四个维度。在这段代码中，`xb`是一个2维张量，所以需要通过重塑操作将其变成对应的4维张量，用于`LeNet`模型的输入。在重塑之后，每个输入图像就被展开为一个形状为 `(1,28,28)` 的三维张量。这个重塑操作中的负数索引是将第一维(即 batch_size)根据第二个维度(即输入图像大小)自适应地计算得到的。

重塑操作之后，就可以将此时的四维张量输入到神经网络中进行前向计算、反向梯度传播以及权重优化等操作了。

### (9) opt. zero_grad() 的作用是什么? 为什么需要有这一步?
在深度学习模型中进行反向传播算法，通常需要首先计算神经网络模型的损失函数，并计算它对相应参数的梯度。接着，使用这些梯度对神经网络模型的参数进行更新，以减小训练误差并提高模型性能。在 PyTorch 中，这个流程通常需要计算完梯度后使用优化器将参数更新，即 `opt.step()` 。

然而，在神经网络模型中进行反向传播算法时，因为使用的是随机梯度下降法（SGD）等优化器，每次进行前向传播计算梯度时，该计算过程会在计算图中累积梯度，调用 `backward()` 函数后，这些累积的梯度会自动累加到每个对应的参数的 `.grad` 属性中，而不会被覆盖。

因此，为了避免当前的梯度和上一次计算的梯度进行叠加，需要在每次 optimizer.step() 后手动把梯度清零，避免一次次累加产生计算误差。

而 `opt.zero_grad()` 这个方法的作用就是将模型参数的梯度设置为0，以避免新一次的梯度更新时被上一次的梯度累计影响，从而保证模型训练过程的正确性。所以，每次经过一次梯度下降或反向传播计算后，都需要通过调用 `opt.zero_grad()` 来清除上一次的累计梯度，`opt.step()` 来执行优化算法的参数更新，从而保证模型能够正确地学习训练数据的特点和结构。
  

### (10)尝试对Irlbslepochs进行调整再观察训练过程。
在深度学习中，训练深度学习模型时需要调节多个参数，以使模型具有更好的性能表现。其中，`lr`、`bs`、`epochs`等参数是模型训练过程中需要进行调节的重要参数。它们分别表示学习率、批量大小和训练轮数(或称为训练迭代次数)。

-   学习率（`lr`）：它控制着每一次参数更新的幅度。在模型训练过程中，学习率可以影响到参数权重的更新速度和更新方向，从而对模型的性能有着很大的影响。如果学习率过大，那么模型可能会发散而无法收敛，如果学习率过小，模型可能会收敛得很慢，从而使得模型的训练时间延长。因此，需要根据实际情况手动设置一个适当的学习率 `lr`。通常情况下，可以从 `1e-5` 到 `1e+3` 之间尝试一些不同的值，然后选择一个最优的值。
-   批量大小 （`bs`）：批量大小指的是在模型训练过程中一次迭代所使用的样本数。批量大小越大，会使得模型学习速度快但不够精细，且在训练时可能会占用更多的内存；批量大小越小，让模型更精细、更稳定，但学习速度会更慢，训练时间可能会变得更长。因此，需要根据实际情况手动设置一个适当的批量大小。通常情况下，常用的批量大小取值范围在 `8`、`16`、`32`、`64`、`128`、`256` 等大小之间。
-   训练轮数（`epochs`）：训练迭代次数是指模型在训练时重复从训练数据集中提取数据、进行前向传播和反向传播等过程的次数。训练轮数的多少决定了模型对训练集数据的学习与拟合程度，影响精度的高低。通常情况下，训练轮数越多，模型的拟合能力就越强，但也会面临过拟合等问题。因此，需要根据实际情况手动设置一个适当的训练轮数。
  

LeNet 就说到这里, 下面来看另一个经典网络 "AlexNet"。相对于LeNet, AlexNet做的改进有:

1. 更深的网络结构。AlexNet使用了比LeNet更深的网络结构, 包含5层卷积层和3层全连接层, 这样可以提取更 高级别的特征, 进而提高模型的准确率。

2. ReLU激活函数的使用。AlexNet在每个卷积层之后都使用了ReLU激活函数, 这个激活函数相比于sigmoid激 活函数可以大大减少梯度消失的问题, 进而训练更深的神经网络。

3. Dropout。AlexNet使用Dropout技术在全连接层中加入随机丟弃部分神经元的操作, 来防止过拟合, 提高模型的泛化能力。

![](res/AlexNet模型结构图.png)

  

### (11)用到的新零件有哪些? 如何定义?
ReLU激活函数使用nn.ReLu()进行定义，Dropout随机失活技术使用nn.Dropout()进行定义
  

### (12)请尝试定义AlexNet网络, 然后将上述过程对应实现



### (13)在同样的数据集, bs和Ir等超参数设置下, 两个网络的训练效果差别是怎样的? 下面进行下一个网络, 何恺明大神的"ResNet"。

![](res/ResNet中的残差(residual)结构.png)

这绝对称得上是"中国之光", 这个网络的出现, 让深度学习网络模型真正可以变深了。请参考我的视频"ResNet 残差神经网络"回答下列问题:

  

### (14)请画出通道数有变化和无变化两种情况下的残差块结构。

  

### (15)在无通道数变化情况下，进入残差块的数据是x，那么输出可以表示为什么? 中间的计算过程是怎样的?

  

### (16)引残差块解决的是什么问题? 请用公式推倒证明。

  

### (17)对于ResNet你还有哪些认识? (背景、作者、影响、延伸等方向不限)

  

如果你有信心, 也可以自己去定义这个网络, 这里就不作要求了。但如果你想使用这个网络, 可以在PyTorch中直 接下载调用预训练好的模型。

  

### (18)如何下载调用? 请下载后重新对MNIST数据集进行训练。

  

上面的模型大多用来对图片进行分类, 下面来说图像处理中的另一个主要任务：目标检测。

  

### (19)相对于图片分类来说, 目标检测是怎样的任务?

  

目标检测中有两种常见解决思路, two stages 和 one stage。

  

其中R-CNN网络可以看做是 two stages 的代表, 后续还有Fast-RCNN和Faster-RCNN。

![](res/R_CNN_regions_with_cnn_features.png)

看我的视频"R-CNN的设计思想"后, 20简述"R-CNN的设计思想"



one stage 的代表当然就是你一定听过的YOLO模型了, 我们来以YOLOv1为例进行学习。

![](res/yolov1_模型结构.png)
  

### (21)测试过程中, 网络的输入图像是多大?

  

### (22)输出的是 \(7 x 7 x 30\) 的张量, 每一个位置的数值分别代表什么意义?

  

### (23)参考下图解释, 模型预测出来的框是98个, 之后经过哪些处理才变为下图中的3个框?

![](res/yolov1模型预测结果.png)
  

### (24)训练过程中, 选用的损失函数是怎样的? 请详细解释。


造不造轮子这个看个人, 但是使用轮子的话, 把具体内容了解清楚了也肯定会收益。强烈建议有余力的同学, 将 本次内容中涉及到的所有论文进行精读, 他们都非常经典。